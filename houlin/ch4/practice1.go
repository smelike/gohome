package main

/*
	一、定义

	载荷器：向被测软件发送指定量的载荷，并记录下被测软件处理载荷的结果。

	一个程序的输入、输出以及二者之间的对应关系，很好地体现出该程序的功能。

	几个必须且重要的参数：

	1、在给定运行环境下，最多能够被多少个用户同时使用；
	2、并行性能测试，需要确定在同一时刻（或在某一时间段内）向软件发送载荷的数量；
	2.1、两个专业术语：QPS(Query Per Second, 每秒查询量)和 TPS(Transactions Per Second, 每秒事务处理量)。
	其含义都是在 1s 之内可正常响应请求的数量的平均值。前者针对的是对服务器上数据的读取操作，后者针对的是对服务器上数据的写入或修改操作。

	3、可以把载荷和请求归为同一个事物，它们都代表了软件使用者为了获得某种结果而向为之服务的软件发送的一段数据。
	4、把每秒发送的载荷数量（以下称每秒载荷量）作为参数，其意义是控制载荷发生器向软件发送载荷的频率。


	二、设计
	参数：每秒载荷量、负载持续时间、处理超时时间。

	载荷发射器根据这些参数，自行计算出载荷发生以及发送的频率。

	载荷的结果至少包含 3 块内容，即：请求（或者说载荷）和响应的内容、响应的状态以及请求处理耗时。


	三、结构体初始化

	3.1 简单、直接的结构体，使用复合字面量来初始化肯定是首选。
	3.2 稍微复杂的结构体，其中某些字段的值需通过计算步骤给出值。
	3.3 Go 中，一般使用一类函数来创建和初始化较复杂的结构体。这类函数的名称常以“New”作为前缀，后跟相关的名词，如：func NewMyGenerator() *myGenerator
	3.4 面向接口编程的原则，不应直接将 myGenerator 或 *myGenerator 作上述函数（初始化函数）的结果类型。原因是该函数及其调用方，与具体实现紧密地绑定在一起。
	如果要修改该结构体类型或换一套载荷发生器的实现，则调用该函数的所有代码不得不被动变化，造成散弹式的修改。
	让这类初始化函数返回一个接口类型的结果是很有必要的，这个接口类型可充分体现出载荷发生器的行为。（初始化函数，返回一个接口类型，接口类型体现载荷发生器的行为）
	3.5 声明接口类型，暴露使用方法：
	type Generator interface {
		// 启动载荷发生器
		// 结果值代表是否已成功启动
		Start() bool
		// 停止载荷发生器 结果值代表是狗已成功停止
		Stop() bool
		// 获取状态
		Status() unit32
		// 获取调用计数。每次启动会重置该计数
		CallCount() int64
	}

	3.6 用于创建和初始化载荷发生器的函数的声明改为：
	func NewGenerator() lib.Generator

	3.7 让 *myGenerator 类型成为接口类型 lib.Generator 的一个实现类型，这需为 *myGenerator 类型编写出与 lib.Generator 接口中声明的方法一一对应的 3 个方法。

	四、执行过程

	一个调用过程代表了载荷发生器通过一个载荷与被测软件进行的一次交互。
	调用过程的并发执行数量（以下简称并发量）需根据 timeoutNS 与 lps 字段的值以及如下公式计算得出：

	并发量 [约等于] 单个载荷的响应超时时间 / 载荷的发送间隔时间

	发送时间间隔可以由载荷发生器的 lps 字段的值计算得出。concurrency、timeoutNS 和 lps 之间的关系如下：
	 concurrency = timeoutNS / (1e9 / lps) + 1
	 (1e9 / lps, 代表每纳秒的载荷发送量)
	 1e9 是 1 s 对应的纳秒数

	预设的限定值：响应超时时间、每秒载荷发送量和负载持续时间，以及经过计算得出的并发量
*/
