package main

/*
	第五章：同步

	互斥锁：传统并发程序对共享资源，进行访问控制的主要手段。
	它由标准库代码包 sync 中的 Mutex 结构类型表示。
	sync.Mutex 类型只有两个公开的指针方法——Lock 和 Unlock。

	sync.Mutex 类型的零值表示未被锁定的互斥量。
	声明： var mutex sync.Mutex

	其他编程语言（如：C、Java）的锁类工具时，可能会犯一个低级错误：忘记及时解开已被锁住的锁，从而导致：流程执行异常、线程执行停滞、程序死锁等系列问题。
	在 Go 中，这个低级错误的发生率极低，主要原因时存在 defer 语句。

	惯用法是：在锁定互斥锁后，紧接着用 defer 语句保证该互斥锁的及时解锁。如下代码片段：

	var mutex sync.Mutex

	func write() {
		mutex.Lock()
		defer mutex.Unlock()
		// 省略若干代码
	}
	defer 语句保证了在该函数执行结束之前，互斥锁 mutex 一定会被解锁，
	因此省去了在所有 return 语句之前，以及异常发生之时重复的附加解锁操作。
	在函数的内部执行流程很复杂的情况下，该工作量不容忽视，且极易遗漏。

	对同一互斥锁的锁定操作和解锁操作要成对出现。
	如果锁定了一个已锁定的互斥锁，那进行重复锁定操作的 goroutine 将被阻塞，直到该互斥锁回到解锁状态。

*/
