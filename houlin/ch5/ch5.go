package main

/*
	第五章：同步

	#5.1.1

	互斥锁：传统并发程序对共享资源，进行访问控制的主要手段。
	它由标准库代码包 sync 中的 Mutex 结构类型表示。
	sync.Mutex 类型只有两个公开的指针方法——Lock 和 Unlock。

	sync.Mutex 类型的零值表示未被锁定的互斥量。
	声明： var mutex sync.Mutex

	其他编程语言（如：C、Java）的锁类工具时，可能会犯一个低级错误：忘记及时解开已被锁住的锁，从而导致：流程执行异常、线程执行停滞、程序死锁等系列问题。
	在 Go 中，这个低级错误的发生率极低，主要原因时存在 defer 语句。

	惯用法是：在锁定互斥锁后，紧接着用 defer 语句保证该互斥锁的及时解锁。如下代码片段：

	var mutex sync.Mutex

	func write() {
		mutex.Lock()
		defer mutex.Unlock()
		// 省略若干代码
	}
	defer 语句保证了在该函数执行结束之前，互斥锁 mutex 一定会被解锁，
	因此省去了在所有 return 语句之前，以及异常发生之时重复的附加解锁操作。
	在函数的内部执行流程很复杂的情况下，该工作量不容忽视，且极易遗漏。

	对同一互斥锁的锁定操作和解锁操作要成对出现。
	如果锁定了一个已锁定的互斥锁，那进行重复锁定操作的 goroutine 将被阻塞，直到该互斥锁回到解锁状态。

	互斥锁的特性：该锁被锁后，只要还未被释放，则无法再次被锁。

	互斥锁锁定操作的逆操作，并不会引起任何 goroutine 的阻塞，但可能引发一个无法恢复的运行时恐慌。

	对未锁定的互斥锁进行解锁操作时，就会引发一个运行时恐慌。
	避免发生该情况的最简单、有效的方式是使用 defer 语句。

	强烈建议：把对同一个互斥锁的锁定和解锁操作，放在同一个层次的代码块中。

	例如：（1）在同一个函数或方法中对某个互斥锁进行锁定和解锁。
	（2）把互斥锁作为某一个结构体类型中的字段，以便该类型的多个方法可使用到。
	代表互斥锁的变量的作用域尽量小。以免在不相关流程中被误用。

	#5.1.2

	读写锁，即针对读写操作的互斥锁。与普通的互斥锁最大的不同，就是可以分别正对读操作和写操作进行锁定和解锁操作。
	读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。
	但多个读操作之间却不存在互斥关系。

	Go 中的读写锁由结构体类型  sync.RWMutex 表示。
	sync.RWMutex 类型的零值就是已经可用的读写锁实例了。
	此类型的方法集合中包含两对方法，即：
	func (*RWMutex) Lock() // 写操作-写锁定
	func (*RWMutex) Unlock() // 写操作-写解锁
	和
	func (*RWMutex) RLock() // 读操作-读锁定
	func (*RWMutex) RUnlock() // 读操作-读解锁


	#5.2 条件变量

	Go 标准库中的 sync.Cond 类型代表了条件变量。

	互斥锁的声明和创建：var mutex sync.Mutex
	读写锁的声明和创建：var rwm sync.RWMutex

	条件变量的声明和创建，需用到 sync.NewCond 函数，该函数声明如下：
	func NewCond(l locker) *Cond

	条件变量总要与互斥量组合使用。sync.NewCond 函数的唯一参数是 sync.Locker 类型的，
	而具体的参数值既可是一个互斥锁(sync.Mutex)，也可为一个读写锁(sync.RWMutex)。

	sync.NewCond 函数在被调用之后，会返回一个 *sync.Cond 类型的结果值，可调用该值拥有的几个方法来操纵这个条件变量。

	*sync.Cond 类型的方法集合有 3 个方法，即：Wait、Signal 和 Broadcast。
	意思分别是：等待通知、单发通知和广播通知的操作。


*/
